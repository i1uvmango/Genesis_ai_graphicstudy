# 01/19 차량 동역학 학습 노트

## 개요 및 이슈
* **과적합(Overfitting):** 과적합된 데이터로 학습됨 -> 메타데이터를 활용해야 함.
* 완전 과적합 상태라면 파라미터 조정 필요.
* **Critic(비평자):** 다소 과할 수 있음. 값을 `*` 수준으로 보정하는 정도라면 Critic 없이도 가능할 수 있음.
* **전략:**
    1. 은닉층(Hidden Layer)을 64, 64, 32, 16 등으로 좁혀가며 분석 진행.
    2. 학습되지 않은(조정되지 않은) 움직임 -> 차이가 확연히 드러나야 함.
    3. **Real to Sim:** 현재 Real to Sim을 진행 중이나, 유의미한 시뮬레이션을 위해서는 **Sim to Real**이 다음 단계여야 함.
    4. **구동계:** 지도학습으로 Real vs Genesis를 맞춰야 하는데... 이를 따로 만드는 것이 맞는지 고민 필요.
    5. 현재 MLP는 단순히 움직임을 맞추는(fit) PPO임. 그렇다면 구동계는 어떻게 맞출 것인가?
    6. 가상 센서 등을 통해 중력 등을 맞춰줘야 함. 이 데이터는 어떻게 추출할 것인가?

* **목표:** 속도/조향(Steer)의 목표는 Blender.
* **지도 학습:** 속도 / 조향.
* **현재 이해:** PPO(우리 모델) + Blender 데이터 정답값 -> 지도 학습으로 MLP 생성.
* **솔버 입력:** Blender와 Genesis의 솔버 입력값이 다름 -> 따라서 솔버의 입력은 Genesis의 상태(State)가 되어야 함.
* 바퀴 마찰 계수 등 고려 필요.

> "두 솔버(Solver)가 공통으로 해석 가능한 상태(State) 공간이 필요하다."
>
> "두 솔버가 서로 다르더라도, 공통적으로 '관측 가능한 결과 공간'을 맞추면 된다."

**이 말이 중요한 이유:**
* **Genesis:** 바퀴 슬립 앵글, 접촉면 힘(Contact patch force), 서스펜션 압축, 제약 충격량(Constraint impulse) 등.
* **Blender:** 비슷해 보이지만 정의가 다름.
* 👉 이를 'State'로 맞추려는 순간, 불가능한 솔버 정렬(Solver-alignment) 문제가 됨.
* "현실에서 센서로 얻을 수 있는 State를 생각할 것."
* **State의 정의:** 두 솔버 모두에서 얻을 수 있고, 실차에서도 측정 가능하며, 물리 결과를 대표하는 것.

![ak](../res/0119/ak.png)

---

## 1. 환경 동기화 (Env Sync - Stage 1)
![stage1_loss](../res/0119/stage1_loss.png)

* **은닉층 구조:** `(128, 128, 64)`

### 필수 컬럼 (입력 데이터 - Raw Data)
* `v_long`: 차량의 전진 속도 (Longitudinal Velocity)
* `v_lat`: 차량의 횡방향(미끄러짐) 속도 (Lateral Velocity)
* `yaw_rate`: 차량의 회전 각속도 (Yaw Rate)
* `g_qw`, `g_qx`, `g_qy`, `g_qz`: 차량의 자세를 나타내는 쿼터니언(Quaternion) 정보

### 생성된 피처 (특성 공학 - Output)
* `roll`, `pitch`: 쿼터니언에서 추출한 차량의 기울기 (오르막/내리막, 좌우 기울임)
* `g_body`: 차체에 작용하는 중력 방향 벡터 (3D)
* `beta`: 차량의 미끄러짐 각도 (Side Slip Angle, `arctan2(v_lat, v_long)`)
* `curvature`: 주행 경로의 곡률 (`yaw_rate / v_long`)
* `lat_accel_hint`: 횡방향 가속도 추정치 (`v_long * yaw_rate`)

### 저장되는 내용 (.pth 파일)
* `model_state_dict`: 학습된 신경망(EnvSyncMLP)의 가중치. (환경적 외란 예측)
* `baseline_decays`: 학습된 물리적 감속 계수. (마찰 계수 등 차량이 얼마나 빨리 멈추는지)
* `scaler_state`, `scaler_env`: 데이터 정규화에 사용된 스케일러 객체. (새로운 데이터 정규화용)
* `config`: 학습 설정값.

### 요약
이 코드는 "8.csv"라는 주행 데이터를 입력받아, 차량이 도로 위에서 어떻게 움직이는지 물리 법칙을 스스로 학습한 뒤, 그 정보를 담은 "env_best_8.pth" 파일을 생성합니다.

---

## 2. 동역학 (Dynamics - Stage 2)
![stage2](../res/0119/stage2.png)

Stage 1이 "환경(경사로, 중력)"을 배웠다면, Stage 2는 **"순수한 차량의 고유한 움직임(핸들을 꺾었을 때 얼마나 확 도는지, 타이어가 얼마나 미끄러지는지)"**을 학습하여 시뮬레이션을 완성하는 단계입니다.

단순 속도뿐만 아니라 `beta`(미끄러짐 각도), `curvature`(회전 반경), `lat_accel`(횡가속도), 과거 상태(`vlat_prev`) 등을 모두 입력으로 사용합니다.

### 모델: ResidualDynamicsMLP
* **입력(14개 피처) $\rightarrow$ 출력(횡방향 속도 잔차, 회전각속도 잔차)**
* 이 모델은 **"핸들을 꺾었을 때 차가 실제로 얼마나 반응하는지"**에 대한 정밀한 물리 엔진 역할을 합니다.
* 가장 바깥 껍질인 **"마찰(Baseline)"**을 벗겨내고, 두 번째 껍질인 **"환경(Stage 1)"**을 벗겨낸 뒤, 가장 안쪽에 남은 **"차량의 진짜 성능(Dynamics)"**만을 학습하여 저장합니다.

### 구조 (Architecture)
```python
nn.Linear(14, 128), nn.ReLU(),
nn.Linear(128, 128), nn.ReLU(),
nn.Linear(128, 64), nn.ReLU(),
nn.Linear(64, 2)
```

### 입력/출력
* **입력 (14개):** 현재 차량의 상태 + 물리적 힌트
    * 속도($v$), 조향각($s$), 미끄러짐 각도($\beta$), 횡가속도($a_{lat}$), 과거 움직임 등 14가지 정밀 데이터
* **출력 (2개):**
    * $\Delta v_{lat}$ (횡방향 속도 잔차): 핸들을 꺾었을 때 타이어가 얼마나 옆으로 미끄러지는지.
    * $\Delta \omega$ (회전 각속도 잔차): 차체가 얼마나 민감하게 회전하는지.

---

## 3. 정답 데이터 (Ground Truth - Refinement)
![inference](../res/0119/inference.png)

이전 단계(Stage 1 & 2)에서 학습한 모델들을 사용하여, 원본 데이터의 불완전한 사람 입력을 **"시뮬레이터에서 실제로 작동하는 완벽한 정답(Ground Truth)"**으로 교정해주는 과정입니다.

### 입력층 (Input Layer - 14 노드)

| 인덱스 | 변수명 | 설명 | 의미 |
| :--- | :--- | :--- | :--- |
| 0 | `v` | 전진 속도 (Longitudinal Velocity) | 앞으로 가는 속도 |
| 1 | `vlat` | 횡방향 속도 (Lateral Velocity) | 차가 옆으로 흐르는 속도 |
| 2 | `yaw` | 회전 각속도 (Yaw Rate) | 차가 회전하는 속도 |
| 3 | `a` | 가속도 (Acceleration) | 전진 속도의 변화량 |
| 4 | `k` | 운동학적 곡률 (Kinematic Curvature) | 핸들링에 의한 회전 반경 비율 |
| 5 | `beta` | 슬립 앵글 (Side Slip Angle) | 차의 진행 방향과 헤딩의 차이 |
| 6 | `pitch` | 피치 (Pitch) | 차의 앞뒤 기울기 |
| 7 | `roll` | 롤 (Roll) | 차의 좌우 기울기 |
| 8 | `v_sq` | 속도 제곱 (Velocity Squared) | 공기 저항 등 반영 |
| 9 | `vlat_prev` | 이전 스텝 횡방향 속도 | 관성(Inertia) 정보 |
| 10 | `yaw_prev` | 이전 스텝 회전 각속도 | 회전 관성 정보 |
| 11 | `curv` | 경로 곡률 (Path Curvature) | 물리적 궤적의 휨 정도 |
| 12 | `lat_acc` | 횡가속도 (Lateral Acceleration) | 원심력 정보 |
| 13 | `beta` | 슬립 앵글 (Side Slip Angle) | (중복 입력/강조됨) |

### 은닉층 (Hidden Layers)
1. 128 노드 + ReLU
2. 128 노드 + ReLU
3. 64 노드 + ReLU

### 출력층 (Output Layer - 2 노드)

| 인덱스 | 변수명 | 설명 |
| :--- | :--- | :--- |
| 0 | $\Delta v_{lat}$ | **횡방향 속도 잔차**: 기본 마찰과 경사로 효과를 제외하고, 핸들 조작으로 인해 추가로 발생한 미끄러짐. |
| 1 | $\Delta \omega$ | **회전 각속도 잔차**: 기본 마찰과 경사로 효과를 제외하고, 핸들 조작으로 인해 추가로 발생한 회전력. |

### 손실 함수 (Loss Function)
$$Loss = \frac{1}{N} \sum (y_{pred} - y_{true})^2$$
**의미:** 모델이 예측한 **잔차(Residual)**와 실제 데이터에서 계산된 잔차(Ground Truth) 사이의 차이를 최소화.

### 3-2. 필터 (Filter)
![alt text](../res/0119/3_filter.png)
* 90%가 들어옴 -> 정답 labeling 이 매우 잘됨
*  **정밀도 필터링:** 최적화 과정에서 오차(loss)가 0.5 이상 발생한 불확실한 데이터는 삭제.
* **포화 상태 제거:** 가속(`t_opt`)이나 조향(`s_opt`)이 물리적 한계치(99% 이상)에 도달한 데이터는 제외 (제어 모델의 유연성 저하 방지).
* *참고: "정답지는 정확해야 함."*

---

## 4. 학습




### 손실 함수
```python
# L = (1.0 * L_throttle) + (1.0 * L_steer)
loss = (cfg.throttle_weight * loss_throttle) + (cfg.steer_weight * loss_steer)
```
* *참고: 스티어링(Steering)에 가중치를 주려 했으나 스로틀(Throttle)이 낮아서 오차가 누적됨.*
#### train 결과
![alt text](../res/0119/4_train.png)
* loss 매우 낮음 &rarr; (steer_b,throttle_b)와 (steer_g,throttle_g)의 차이가 매우 작음.

### 입력 변수 (8개 피처)
모델은 주행 중인 차량의 상태를 나타내는 다음 8가지 핵심 단서를 보고 판단합니다.

| 분류 | 변수명 | 설명 |
| :--- | :--- | :--- |
| 현재 상태 | `v_long`, `yaw_rate` | 현재 차량의 속도와 회전 빠르기 |
| 사람의 습관 | `throttle_norm`, `steer` | 원본 데이터에서 사람이 입력했던 제어량 (힌트) |
| 공간적 오차 | `cte`, `heading_err` | 현재 경로에서 옆으로 벗어난 거리와 각도 오차 |
| 미래 정보 | `la_cte`, `la_h_err` | Look-ahead 지점에서의 예측 오차 |

* **은닉층 구조:** $128 \rightarrow 128 \rightarrow 64$

* **출력:** `throttle_g`, `steering_g`


### open loop & closed loop 개념

### 오픈 루프 (Open Loop)
<video controls src="../res/0119/openloop.mp4" title="Open Loop"></video>
* 오픈 루프는 입력이 출력에 영향을 주지만, 출력이 다시 입력에 영향을 주지 않는 방식입니다. 즉, "일단 명령을 내렸으면 결과가 어떻든 상관하지 않는다"는 쿨한(하지만 위험한) 방식이죠.
구조: 입력(Input) $\rightarrow$ 제어기(Controller) $\rightarrow$ 프로세스(Process) $\rightarrow$ 출력(Output)특징:피드백(Feedback)이 없습니다.외부 방해(외란)나 환경 변화에 대응하지 못합니다.구조가 단순하고 비용이 저렴합니다.

### 클로즈드 루프 (Closed Loop)
<video controls src="../res/0119/closed_mlp.mp4" title="Closed Loop"></video>
* 클로즈드 루프는 출력 결과를 센서로 측정하여 다시 입력으로 보내는(Feedback)방식입니다. 목표값과 현재값의 차이(오차)를 계산해서 실시간으로 보정합니다.
특징:

피드백 루프가 존재합니다.

오차(Error)를 줄이는 방향으로 계속 수정하므로 정확도가 높습니다.

외부 방해에 강합니다 (예: 바람이 불어도 자동차가 차선을 유지함).

구조가 복잡하고 설계 비용이 높습니다.
---

## 5. 추론 (Inference)
* **입력 (8D):** 현재 속도, 회전율, 사람의 힌트, CTE/Heading Error (현재 및 미래).
* **출력 (2D):** `t_opt` (가속), `s_opt` (조향) -> Tanh (-1 ~ 1)를 거쳐 제어(Control)로 입력됨.

<video controls src="5.mp4" title="Title"></video>
